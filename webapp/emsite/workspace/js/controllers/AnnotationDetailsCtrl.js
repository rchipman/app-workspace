// Generated by CoffeeScript 1.4.0

Workspace.controller('AnnotationDetailsCtrl', [
  '$rootScope', '$scope', '$stateParams', '$timeout', 'annotationService', 'fabricJsService', function($rootScope, $scope, $stateParams, $timeout, annotationService, fabricJsService) {
    var commentPin, metaUser, timeoutFunc, usefulKeys;
    $rootScope.$broadcast('navigatedTo', 'Annotations');
    $scope.selectable = false;
    $scope.canSelect = function() {
      return $scope.selectable;
    };
    $scope.color = '#000fff';
    $scope.brushWidth = 5;
    self.mouseDown = null;
    self.origX = 0;
    self.origY = 0;
    $scope.currentCommentIndex = 1;
    $scope.newCommentText = null;
    $scope.annotations = [];
    metaUser = {
      type: 'normal',
      name: 'Rob',
      email: md5('jrchipman1@gmail.com')
    };
    $scope.currentUser = metaUser;
    $scope.events = [];
    $scope.comments = [];
    $scope.thumbs = [
      {
        name: 'Maybe Art',
        src: 'img/BlueBus.jpg',
        id: 104
      }, {
        name: 'Stupid Art',
        src: 'img/ForMom.jpg',
        id: 101
      }, {
        name: 'Nice Art',
        src: 'img/FenceDog.jpg',
        id: 102
      }, {
        name: 'Great Art',
        src: 'img/TigerTug.jpg',
        id: 103
      }
    ];
    $scope.loadImages = function() {
      var markers;
      markers = {
        "query": [
          {
            "field": "id",
            "operator": "matches",
            "values": ["*"]
          }
        ]
      };
      $.ajax({
        type: "POST",
        url: "/entermedia/services/json/search/data/asset?catalogid=media/catalogs/public",
        data: JSON.stringify(markers),
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        async: false,
        success: function(data) {
          var tempArray;
          tempArray = [];
          $.each(data.results, function(index, obj) {
            var path;
            path = "http://localhost:8080/emshare/views/modules/asset/downloads/preview/thumbsmall/" + obj.sourcepath + "/thumb.jpg";
            console.log(path);
            console.log(fabric.util.loadImage(path, function(src) {
              return em.unit;
            }));
            return em.unit;
          });
          return em.unit;
        },
        failure: function(errMsg) {
          alert(errMsg);
          return em.unit;
        }
      });
      return em.unit;
    };
    $scope.removeComment = function(annotationid) {
      var which;
      which = _.findWhere($scope.annotations, {
        id: annotationid
      });
      $scope.fabric.canvas.remove(which.group);
      $scope.annotations = _.without($scope.annotations, which);
      return em.unit;
    };
    $scope.addComment = function() {
      var annotationSpec, obj, pin, pinnedGroup, _i, _len, _ref;
      pin = commentPin();
      $scope.currentAnnotationGroup.push(pin);
      pinnedGroup = new fabric.Group($scope.currentAnnotationGroup);
      _ref = $scope.currentAnnotationGroup;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        $scope.fabric.canvas.remove(obj);
      }
      pinnedGroup._restoreObjectsState();
      $scope.fabric.canvas.add(pinnedGroup);
      annotationSpec = {
        id: $scope.currentCommentIndex++,
        group: pinnedGroup,
        user: $scope.currentUser,
        comment: {
          type: 'normal',
          text: $scope.newCommentText,
          timestamp: moment().fromNow()
        }
      };
      $scope.annotations.unshift(annotationSpec);
      $scope.currentAnnotationGroup = [];
      $scope.newCommentText = null;
      $scope.readyToComment = false;
      return em.unit;
    };
    $scope.selectTool = function(toolname) {
      var prop;
      $scope.currentTool = _.findWhere($scope.fabric.toolkit, {
        name: toolname
      });
      for (prop in $scope.currentTool.properties) {
        $scope.fabric.canvas[prop] = $scope.currentTool.properties[prop];
      }
      if ($scope.currentTool.name === 'draw') {
        $scope.fabric.canvas.freeDrawingBrush.color = $scope.color;
        $scope.fabric.canvas.freeDrawingBrush.width = $scope.brushWidth;
      }
      return em.unit;
    };
    usefulKeys = [''];
    $scope.currentAnnotation = _.find(annotationService.mockData, function(item) {
      return item.annotation.id === parseInt($stateParams.annotationID);
    });
    $scope.fabric = fabricJsService.init($scope.currentAnnotation.annotation.path);
    $scope.selectTool('draw');
    $scope.eventIndex = 0;
    $scope.annotationAction = null;
    $scope.currentAnnotationGroup = [];
    $scope.currentAnnotationGroupId = 0;
    /*
    	This whole process is muddled, what should happen is simple:
    	user clicks to draw a shape, that shape is added to the current group upon object:added
    	a timeout function begins to check if they are done annotating
    	if the user clicks again within a time window, the timeout function is cancelled
    	repeat process until...
    	user finishes annotation, they should be prompted for a comment
    	a pin should be created and added into the annotationGroup data
    	the pin should be rendered on screen somewhere appropriate and...
    	the comment should be added to scope with annotationGroup data to be attached to comment
    */

    $scope.cancelComment = function() {
      console.log($scope.currentAnnotationGroup);
      console.log($scope.currentAnnotationGroupId);
      console.log($scope.currentCommentIndex);
      return console.log($scope.annotations);
    };
    commentPin = function() {
      return new fabric.Group([
        new fabric.Circle({
          radius: 18.5,
          fill: "#fff"
        }), new fabric.Circle({
          radius: 14,
          fill: "#4fabe5",
          top: 5,
          left: 5
        }), new fabric.Text($scope.currentCommentIndex.toString(), {
          fontSize: 20,
          fill: "#fff",
          left: 13,
          top: 4
        })
      ], {
        evented: false,
        top: self.origX,
        left: self.origY,
        lockScalingX: false,
        lockScalingY: false,
        selectable: (function() {
          return $scope.selectable;
        })()
      });
    };
    timeoutFunc = function() {
      $scope.events.push({
        id: $scope.eventIndex += 1,
        text: 'Object added!'
      });
      $scope.readyToComment = true;
      $timeout((function() {
        return $('#user-comment-input').focus();
      }), 100);
      $scope.selectTool('disabled');
      $scope.$apply();
      return em.unit;
    };
    $scope.fabric.canvas.on('mouse:down', function(e) {
      var pointer, _ref;
      self.mouseDown = true;
      if ($scope.annotationAction !== null) {
        $timeout.cancel($scope.annotationAction);
      }
      pointer = $scope.fabric.canvas.getPointer(e.e);
      self.origX = pointer.x;
      self.origY = pointer.y;
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mousedown === "function") {
          _ref.mousedown(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:up', function(e) {
      var _ref;
      self.mouseDown = false;
      if ($scope.currentTool.annotating) {
        $scope.annotationAction = $timeout(timeoutFunc, 2000);
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mouseup === "function") {
          _ref.mouseup(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:move', function(e) {
      var _ref;
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mousemove === "function") {
          _ref.mousemove(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('object:added', function(obj) {
      var _ref;
      if ($scope.currentTool.annotating) {
        obj.target.selectable = (function() {
          return $scope.selectable;
        })();
        $scope.currentAnnotationGroup.push(obj.target);
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.objectadded === "function") {
          _ref.objectadded(obj, $scope.fabric.canvas);
        }
      }
      $scope.fabric.canvas.renderAll();
      $scope.fabric.canvas.calcOffset();
      if (!self.origX) {
        self.origX = obj.target.top - 15;
      }
      if (!self.origY) {
        self.origY = obj.target.left - 15;
      }
      return em.unit;
    });
    return em.unit;
  }
]);
